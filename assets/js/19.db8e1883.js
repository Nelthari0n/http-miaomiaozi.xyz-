(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{663:function(e,s,a){"use strict";a.r(s);var t=a(5),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("Boxx",{attrs:{blockStyle:e.blockStyle}}),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("我们在浏览器中输入以下代码")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(0.1 + 0.2 === 0.3)\nfalse\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("我们发现 在 js 中 0.1 + 0.2 不等于 0.3")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(0.1 + 0.2)\n0.30000000000000004\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("而是一个很奇怪的值")]),e._v(" "),a("h2",{attrs:{id:"ieee754"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ieee754"}},[e._v("#")]),e._v(" IEEE754")]),e._v(" "),a("p",[e._v("众所周知 JS 仅有 Number 这个数值类型，而 Number 采用的时 IEEE 754 64 位双精度浮点数编码。而浮点数表示方式具有以下特点：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("浮点数可表示的值范围比同等位数的整数表示方式的值范围要大得多")])]),e._v(" "),a("li",[a("p",[e._v("浮点数无法精确表示其值范围内的所有数值，而有符号和无符号整数则是精确表示其值范围内的每个数值")])]),e._v(" "),a("li",[a("p",[e._v("浮点数只能精确表示 m*2e 的数值")])]),e._v(" "),a("li",[a("p",[e._v("当 biased-exponent 为 2e-1-1 时，浮点数能精确表示该范围内的各整数值")])]),e._v(" "),a("li",[a("p",[e._v("当 biased-exponent 不为 2e-1-1 时，浮点数不能精确表示该范围内的各整数值")])])]),e._v(" "),a("p",[e._v("由于部分数值无法精确表示（存储），于是在运算统计后偏差会愈见明显")]),e._v(" "),a("h2",{attrs:{id:"why-0-1-0-2-0-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-0-1-0-2-0-3"}},[e._v("#")]),e._v(" why 0.1 + 0.2 !== 0.3")]),e._v(" "),a("p",[e._v("十进制的 0.1 转为二进制，得到一个无限循环小数：0.00011… 也就是说，二进制无法「用有限的位数」来表示 0.1\n同理 0.2 也一样\n但是计算机只能用有限的位数来存一个数，所以最终，计算机存的数是一个近似于 0.1 的小数\n所以当我们计算 0.1 + 0.2 时，实际上算的是两个近似值相加，得到的值当然也是近似等于 0.3")]),e._v(" "),a("h2",{attrs:{id:"结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[e._v("#")]),e._v(" 结论")]),e._v(" "),a("ol",[a("li",[e._v("为什么 0.1 + 0.2 不等于 0.3。十进制小数转为二进制小数的过程中，会损失精度")]),e._v(" "),a("li",[e._v("并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差")]),e._v(" "),a("li",[e._v("具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正”")])]),e._v(" "),a("h2",{attrs:{id:"怎么解决这类问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么解决这类问题"}},[e._v("#")]),e._v(" 怎么解决这类问题")]),e._v(" "),a("ol",[a("li",[e._v("使用整型代替浮点数计算")]),e._v(" "),a("li",[e._v("不要直接比较两个浮点数，而应该使用 bignumber.js 这样的浮点数运算库")])])],1)}),[],!1,null,null,null);s.default=r.exports}}]);