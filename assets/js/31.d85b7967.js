(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{676:function(a,r,t){"use strict";t.r(r);var l=t(5),n=Object(l.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("Boxx",{attrs:{blockStyle:a.blockStyle}}),a._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("ul",[t("li",[a._v("临近过年闲的无事想着试试把 vuepress 升级到 2.0，但是发现了主题有很多的问题，又把 vuepress 换回了 1.几的版本，但是编译的时候老报错，可能当时不是很清醒，过了 20 分钟上厕所的想到应该是 yarn.lock 锁了版本号，把 yarn.lock 删了之后重新安装编译通过。")])]),a._v(" "),t("h2",{attrs:{id:"yarn-lock-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn-lock-是什么"}},[a._v("#")]),a._v(" yarn.lock 是什么")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("为了在多台机器之间获得一致的安装结果，Yarn 可能会需要比 package.json 文件中配置的依赖项更多的信息。它需要准确存储每一个依赖项的安装版本。因此在 Yarn 项目的根目录我们需要一个 yarn.lock 文件，这个 yarn.lock 文件是自动生成的。")])]),a._v(" "),t("li",[t("p",[a._v("当我们执行 yarn 命令或者添加依赖包命令后，Yarn 都会在项目根目录下自动生成一个 yarn.lock 文件。在使用 Yarn 安装、升级、删除依赖项目时，会自动更新到 yarn.lock 文件中。")])])]),a._v(" "),t("h2",{attrs:{id:"yarn-lock-有什么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yarn-lock-有什么用"}},[a._v("#")]),a._v(" yarn.lock 有什么用")]),a._v(" "),t("ul",[t("li",[a._v("锁定唯一版本")]),a._v(" "),t("li",[a._v("锁定你安装的每个依赖项的版本，这可以确保你不会意外获得不良依赖")]),a._v(" "),t("li",[a._v("并且会避免由于开发人员意外更改或则更新版本，而导致糟糕的情况")])]),a._v(" "),t("h2",{attrs:{id:"注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[a._v("#")]),a._v(" 注意事项")]),a._v(" "),t("ul",[t("li",[a._v("升级依赖后，一定要同时提交 package.json 和 yarn.lock")])])],1)}),[],!1,null,null,null);r.default=n.exports}}]);